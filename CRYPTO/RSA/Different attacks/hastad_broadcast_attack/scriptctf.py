#!/usr/bin/env python3
from math import isqrt

# Given values
n1 = 156503881374173899106040027210320626006530930815116631795516553916547375688556673985142242828597628615920973708595994675661662789752600109906259326160805121029243681236938272723595463141696217880136400102526509149966767717309801293569923237158596968679754520209177602882862180528522927242280121868961697240587
c1 = 77845730447898247683281609913423107803974192483879771538601656664815266655476695261695401337124553851404038028413156487834500306455909128563474382527072827288203275942719998719612346322196694263967769165807133288612193509523277795556658877046100866328789163922952483990512216199556692553605487824176112568965

n2 = 81176790394812943895417667822424503891538103661290067749746811244149927293880771403600643202454602366489650358459283710738177024118857784526124643798095463427793912529729517724613501628957072457149015941596656959113353794192041220905793823162933257702459236541137457227898063370534472564804125139395000655909
c2 = 40787486105407063933087059717827107329565540104154871338902977389136976706405321232356479461501507502072366720712449240185342528262578445532244098369654742284814175079411915848114327880144883620517336793165329893295685773515696260299308407612535992098605156822281687718904414533480149775329948085800726089284

n3 = 140612513823906625290578950857303904693579488575072876654320011261621692347864140784716666929156719735696270348892475443744858844360080415632704363751274666498790051438616664967359811895773995052063222050631573888071188619609300034534118393135291537302821893141204544943440866238800133993600817014789308510399
c3 = 100744134973371882529524399965586539315832009564780881084353677824875367744381226140488591354751113977457961062275480984708865578896869353244823264759044617432862876208706282555040444253921290103354489356742706959370396360754029015494871561563778937571686573716714202098622688982817598258563381656498389039630

e = 3

# Extended GCD and modular inverse
def egcd(a, b):
    if b == 0:
        return (1, 0, a)
    x, y, g = egcd(b, a % b)
    return (y, x - (a // b) * y, g)

def invmod(a, m):
    x, _, g = egcd(a, m)
    if g != 1:
        raise Exception("no inverse")
    return x % m

# Chinese Remainder Theorem
N = n1 * n2 * n3
total = 0
for n, c in [(n1, c1), (n2, c2), (n3, c3)]:
    M = N // n
    inv = invmod(M, n)
    total = (total + c * M * inv) % N

# Integer k-th root
def iroot(k, n):
    low, high = 0, 1 << ((n.bit_length() // k) + 2)
    while low <= high:
        mid = (low + high) // 2
        p = mid**k
        if p == n:
            return mid, True
        if p < n:
            low = mid + 1
        else:
            high = mid - 1
    return high, False

# Recover message
m, _ = iroot(e, total)
pt = m.to_bytes((m.bit_length() + 7) // 8, "big")
print(pt.decode(errors="ignore"))
